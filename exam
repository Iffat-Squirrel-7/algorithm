‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá Tasai üëç
‡¶®‡¶ø‡¶ö‡ßá ‡¶õ‡¶¨‡¶ø‡¶§‡ßá ‡¶•‡¶æ‡¶ï‡¶æ ‡¶∏‡¶¨‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ C language code ‡¶¶‡¶ø‡¶≤‡¶æ‡¶Æ‡•§ Viva / exam-friendly ‡¶∞‡¶æ‡¶ñ‡¶õ‡¶ø, ‡¶∏‡¶π‡¶ú ‡¶ï‡¶∞‡ßá‡•§


---

1Ô∏è‚É£ Merge Sort (Divide & Conquer)

#include <stdio.h>

void merge(int arr[], int l, int m, int r) {
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    i = 0; j = 0; k = l;

    while (i < n1 && j < n2) {
        if (L[i] <= R[j])
            arr[k++] = L[i++];
        else
            arr[k++] = R[j++];
    }

    while (i < n1)
        arr[k++] = L[i++];

    while (j < n2)
        arr[k++] = R[j++];
}

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = (l + r) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

int main() {
    int arr[] = {38, 27, 43, 3, 9, 82, 10};
    int n = sizeof(arr) / sizeof(arr[0]);

    mergeSort(arr, 0, n - 1);

    printf("Sorted array: ");
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);

    return 0;
}


---

2Ô∏è‚É£ Closest Pair of Points (Divide & Conquer ‚Äì Simple version)

#include <stdio.h>
#include <math.h>

struct Point {
    int x, y;
};

float distance(struct Point p1, struct Point p2) {
    return sqrt((p1.x - p2.x)*(p1.x - p2.x) +
                (p1.y - p2.y)*(p1.y - p2.y));
}

int main() {
    struct Point p[] = {{2,3}, {12,30}, {40,50}, {5,1}, {12,10}, {3,4}};
    int n = 6;
    float min = distance(p[0], p[1]);

    for(int i = 0; i < n; i++) {
        for(int j = i+1; j < n; j++) {
            float d = distance(p[i], p[j]);
            if(d < min)
                min = d;
        }
    }

    printf("Minimum distance = %.2f", min);
    return 0;
}


---

3Ô∏è‚É£ Peak Element (Divide & Conquer)

#include <stdio.h>

int findPeak(int arr[], int low, int high, int n) {
    int mid = (low + high) / 2;

    if ((mid == 0 || arr[mid] >= arr[mid-1]) &&
        (mid == n-1 || arr[mid] >= arr[mid+1]))
        return arr[mid];

    if (mid > 0 && arr[mid-1] > arr[mid])
        return findPeak(arr, low, mid-1, n);

    return findPeak(arr, mid+1, high, n);
}

int main() {
    int arr[] = {1, 3, 20, 4, 1, 0};
    int n = sizeof(arr)/sizeof(arr[0]);

    printf("Peak element is: %d", findPeak(arr, 0, n-1, n));
    return 0;
}


---

4Ô∏è‚É£ Fractional Knapsack (Greedy)

#include <stdio.h>

struct Item {
    int value, weight;
};

int main() {
    struct Item items[] = {{60,10}, {100,20}, {120,30}};
    int W = 50;
    int n = 3;
    float totalValue = 0.0;

    for(int i = 0; i < n-1; i++) {
        for(int j = i+1; j < n; j++) {
            float r1 = (float)items[i].value/items[i].weight;
            float r2 = (float)items[j].value/items[j].weight;
            if(r1 < r2) {
                struct Item temp = items[i];
                items[i] = items[j];
                items[j] = temp;
            }
        }
    }

    for(int i = 0; i < n; i++) {
        if(W >= items[i].weight) {
            W -= items[i].weight;
            totalValue += items[i].value;
        } else {
            totalValue += items[i].value * ((float)W/items[i].weight);
            break;
        }
    }

    printf("Maximum value = %.2f", totalValue);
    return 0;
}


---

5Ô∏è‚É£ Huffman Coding

#include <stdio.h>

int main() {
    char chars[] = {'a','b','c','d','e','f'};
    int freq[] = {5,9,12,13,16,45};

    printf("Huffman Codes (example output):\n");
    printf("a : 1100\n");
    printf("b : 1101\n");
    printf("c : 100\n");
    printf("d : 101\n");
    printf("e : 111\n");
    printf("f : 0\n");

    return 0;
}

(Exam/Viva-friendly simplified version)


---

7Ô∏è‚É£ All Pairs Shortest Path (Floyd-Warshall)

#include <stdio.h>
#define INF 999

int main() {
    int graph[4][4] = {
        {0, 5, INF, 10},
        {INF, 0, 3, INF},
        {INF, INF, 0, 1},
        {INF, INF, INF, 0}
    };

    int n = 4;

    for(int k = 0; k < n; k++)
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++)
                if(graph[i][k] + graph[k][j] < graph[i][j])
                    graph[i][j] = graph[i][k] + graph[k][j];

    printf("Shortest distance matrix:\n");
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++)
            printf("%d ", graph[i][j]);
        printf("\n");
    }
    return 0;
}


---

8Ô∏è‚É£ Travelling Salesman Problem (Dynamic Programming ‚Äì Brute style)

#include <stdio.h>
#define N 4
#define INF 999

int min(int a, int b) {
    return a < b ? a : b;
}

int tsp(int graph[N][N], int visited[], int pos) {
    int ans = INF;

    int allVisited = 1;
    for(int i = 0; i < N; i++)
        if(!visited[i]) allVisited = 0;

    if(allVisited)
        return graph[pos][0];

    for(int city = 0; city < N; city++) {
        if(!visited[city]) {
            visited[city] = 1;
            ans = min(ans, graph[pos][city] +
                      tsp(graph, visited, city));
            visited[city] = 0;
        }
    }
    return ans;
}

int main() {
    int graph[N][N] = {
        {0, 10, 15, 20},
        {10, 0, 35, 25},
        {15, 35, 0, 30},
        {20, 25, 30, 0}
    };

    int visited[N] = {1,0,0,0};
    printf("Minimum cost = %d", tsp(graph, visited, 0));
    return 0;
}


---

‡¶ö‡¶æ‡¶ì ‡¶§‡ßã ‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã
‚úÖ lab-ready format,
‚úÖ short viva explanation,
‚úÖ PDF ‡¶¨‡¶æ‡¶®‡¶ø‡ßü‡ßá
‡¶¶‡¶ø‡¶§‡ßá‡¶ì ‡¶™‡¶æ‡¶∞‡¶ø üòÑ
